#ifndef LOGGER_H
#define LOGGER_H

// Include from boost log
#define BOOST_LOG_DYN_LINK

#include <boost/log/utility/setup/common_attributes.hpp>
#include <boost/log/sources/global_logger_storage.hpp>
#include <boost/date_time/gregorian/gregorian.hpp>
#include <boost/log/sources/severity_logger.hpp>
#include <boost/log/sources/record_ostream.hpp>
#include <boost/log/attributes/function.hpp>
#include <boost/log/sources/logger.hpp>
#include <boost/log/expressions.hpp>
#include <boost/log/sinks.hpp>
#include <boost/log/core.hpp>

//----------

#include <QObject>
#include <QString>

//To keep the code simple, the following namespace aliases are defined:
namespace logging = boost::log;
namespace sinks = boost::log::sinks;
namespace src = boost::log::sources;
namespace expr = boost::log::expressions;
namespace attrs = boost::log::attributes;
namespace keywords = boost::log::keywords;

class Logger : public QObject
{
    Q_OBJECT
public:

   /**
   * Logger::severity_level enum its our own severity definitions
   * Severity is used to define how important is the log record.
   *
   * \par Example:
   *  When the writeRecord function is called the severity level must be informed. To pass the the severity uses:
   * \code
   *  Logger::info
   * \endcode
   *
   * @see writeRecord()
   */
    enum severity_level
    {
        info, /**< It used when the record is about an important event but common or expected */
        debug, /**< Used to write record only if debug mode is on */
        warning, /**< Used to describe an important negative event. It is not an error but needs attention */
        error, /**< Used when an error occurs. The system keeps running, but something important can't be done */
        critical, /**< Critical severity means that some part of the system doesn't work properly and something very important can't be done */
        fatal /**< Fatal severity means some event really bad and the system going to quit */
    };

    /**
     * @brief sink_t indicates that the sink is synchronous, that is, it allows for several threads to log simultaneously and will block in case of contention.
     */
    typedef sinks::synchronous_sink< sinks::text_file_backend > sink_t;

    /**
     * @brief instance return the unique instance of the \c Logger class
     *
     * At the first call of this function it will init the class by calling the constructor of the class and than init logger by calling an initLog function.
     * Both Logger class constructor and initLog function are private, because only one instance of the class must be created and logger configuration must be made just once.
     *
     * @return The unique reference to the instance of the class
     */
    static Logger * instance();

    /**
     * @brief writeRecord function that recive the parameters to be write into log record, create the attributes and write logs.
     *
     * This function write the log record into log file. Use the parameters received to configure and create a log record and write this record into a log file.
     * The formater of the record is:
     * \code
     *  00001 % 05-25-2013_16:05:45 % severity % Module Name % Void functionName() % Any message
     * \endcode
     * The first token (the tokens are separated by %) is the record ID which is generated by boost.log library;
     * Second token is the date and time when the record was created. The date and time is ofered by currentDateTime function and it is called when every log record is generated. The format used is: MM-dd-yyyy_hh:mm:ss;
     * Third token is the severity level of record and is ofered by Logger::severity_level;
     * Fourth token is the name of the module that is writing an log;
     * Fifth token is the signature of function that is writing an log. The function signature is ofered by Q_FUNC_INFO from Qt.
     * Sixth token is an message that will inform what happened.
     *
     * \par Example
     * To call the writeRecord() function is used the follow statement, with the required parameters:
     * \code
     * #include <logger.h>
     * \endcode
     * \code
     * Logger::instance()->writeRecord(Logger::info, "Module Name", Q_FUNC_INFO, "Hello from log record");
     * \endcode
     *
     * @param lvl severity level for the record
     * @param moduleName it the name of the module from where the Logger wrote the record
     * @param FunctionName it the signature of the functions from where the Logger wrote the record
     * @param message to inform what happened
     *
     * @see currentDateTime()
     * @see severity_level
     */
    void writeRecord(severity_level lvl, QString moduleName, QString FunctionName,
                     QString message);

    /**
     * @brief currentDateTime return a std::string with the current date and time
     *
     * Each log records requires a date and time when the record was generated. So, when a log record is generated, this function is called and return an date and time string with the follow format:
     * \code
     * MM-dd-yyyy_hh:mm:ss -> 09-26-2013_16:46:20
     * \endcode
     *
     * @return std::string with the current time to append in log record. The return is a std::string because the boost.log library can't handle with QString
     */
    static std::string currentDateTime();

    /**
     * @brief writeLastRecord it called before close log file
     *
     * When a log file is opened, the system write a record into it, to inform the start time.
     * Before open a log file, the system verifies if it already exists and in affirmative case open to append records. But the system doesn't write a record when stop.
     *
     * @param file stream to the log file
     */
    static void writeLastRecord(sinks::text_file_backend::stream_type &file);

    /**
     * @brief startDebugMode it called when system is running in debug mode
     *
     * The system running in debug mode will generate more logs than normal running. It will create a record for each step of execution and will logging exactly what happened.
     * Debug mode can be used to detect any abnormal execution, error or why the system is crashing and figure out the point of the crash and then solve the problem.
     * This function must be called only once, and it will configure and create a log file called Log_DEBUG_%Y%m_%H%M%S.log in the log directory.
     * Every time that the system starts as a debug mode a new debug log file is created.
     * To call this function use: \code Logger::instance()->startDebugMode(); \endcode
     */
    void startDebugMode();

private:

    /**
     * @brief logformat define the format of the log records
     *
     * Each log records has attributes and the logformat define how these attributes are write in log file.
     * logformat is created and configured in Logger class constructor and is used to set records format in functions startDebugMode() and initLog().
     * The format used is like:
     * \code
     * 00001 % 05-25-2013_16:05:45 % severity % Module Name % Void functionName() % Any message
     * \endcode
     *
     * @see startDebugMode()
     * @see initLog()
     */
    logging::formatter logformat;

    explicit Logger(QObject *parent = 0);

    /**
     * @brief initLog will configure and create a log file
     *
     * The initLog function will be called at the first time that the Logger class is instantiated and will verify if already exist log files in log directory.
     * If a log file already exists it will be open to append new records.
     * A new log file is created if non exists any files in log directory or if the exists file size is bigger than 5MB. The names sequence to these log files are like:
     * \code
     * Log_%Y%m_%N.log -> Log_201309_1.log Log_201309_2.log ...
     * \endcode
     * This function is private because it must to be called only once and only by instance() function.
     *
     * @see instance()
     */
    void initLog();

};

BOOST_LOG_ATTRIBUTE_KEYWORD(line_id, "LineID", unsigned int)
BOOST_LOG_ATTRIBUTE_KEYWORD(severity, "Severity", Logger::severity_level)

#endif // LOGGER_H
